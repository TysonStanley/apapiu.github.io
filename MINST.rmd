---
title: "Minst"
output: html_document
---

We will be looking at the MNIST data set on Kaggle. The goal in this competition is to take an image of a handwritten single digit, and determine what that digit is.

Let's load up the data from the Kaggle  [competition]("https://www.kaggle.com/c/digit-recognizer/data"):

```{r}
library(ggplot2)
library(gridExtra)
train <- read.csv("train.csv")
```

Let's look at the dimension of train.

```{r}
dim(train)
head(train[1:8])
train$label <- as.factor(train$label)
```

So we basically have `r dim(train)[1]` examples with each example having `r dim(train)[2] - 1 ` features - pixels in this case and a label - the digit the image represent. It's actually pretty easy to reconstruct the image from the vector of pixels and we do this below. First I construct a square matrix form the vector and then use `image` to diplay it.

```{r}
digit <- matrix(as.numeric(train[8,-1]), nrow = 28) #look at one digit
image(digit, col = grey.colors(255))
```

Looks like a 3! 

Since I want this to be a self-contained reproducible post I will split the training set into a test set and a training set just so I don't have to log into Kaggle to test the results. 



Let's play around and see if we can extract any features from the pixels that can be more informative. First I'd like to know more about average intensity - that is the average value of a pixel in an image for the different digits. Intuition tells me that the digit "1" will have on average have less intensity than say an "8". Below I create a new feature that is the average of the pixel intensity and then use the R function `aggregate` (extermely useful in these situations) to look at averages by label. Then I plot the average intensity using `qplot` frmo the `ggplot2` package.

```{r}
train$intensity <- apply(train[,-1], 1, mean) #takes the mean of each row in train

intbylabel <- aggregate (train$intensity, by = list(train$label), FUN = mean)

plot <- ggplot(data=intbylabel, aes(x=Group.1, y = x)) +
    geom_bar(stat="identity")
plot + scale_x_discrete(limits=0:9) + xlab("digit label") + 
    ylab("average intensity")
```

As we can see there are some differences in intensity. The digit "1" is the less intense while the digit "0" is the most intense. So this new feature seems to have some predictive value if you wanted to know if say your digit is a "1" or no. But the problem of course is that **different peple write their digits differently**. We can get a sense of this by plotting the distribution of the average intensity by label.

```{r}
ggplot(train, aes(x=intensity)) + 
    geom_density(aes(group= label, fill=as.factor(label)), alpha=0.3)
```

What can we observe from the histograms above? Well most intensity distributions seem roughly normally distributed but some have higher variance than others. The digit "1" seems to be the one people write most consistently across the board. Other than that the intensity feature isn't all that helpful. Also sometimes density plots can be decieving so let's plos some historgrams for selected numbers. My guess is that 4 and 7 will have the highest variablilty. Growing up in Romania I was taught to "line" my sevens. In the US people don't really do that, but I'm curious if there are other weirdos like me :)

```{r}


p1 <- qplot(subset(train, label ==1)$intensity, binwidth = .75, 
            xlab = "Intensity Histogram for 1")

p2 <- qplot(subset(train, label ==4)$intensity, binwidth = .75,
            xlab = "Intensity Histogram for 4")

p3 <- qplot(subset(train, label ==7)$intensity, binwidth = .75,
            xlab = "Intensity Histogram for 7")

p4 <- qplot(subset(train, label ==9)$intensity, binwidth = .75,
            xlab = "Intensity Histogram for 9")

grid.arrange(p1, p2, p3,p4, ncol = 2)
```
It does seem that the intensity distributions for 4 and 7 are less "normal" than the distrubution for 1. The diestribution for 4 looks almost bimodal - a telling sign thay perhaps there are two different ways people tend to write their fours.
Let's take a look at some images of fours and sevens.

```{r}
train4 <- train[train$label == 4, ]
train7 <- train[train$label == 7, ]

flip <- function(matrix){
    apply(matrix, 2, rev)
}

par(mfrow=c(3,3))
for (i in 20:28){
    digit <- flip(matrix(rev(as.numeric(train4[i,-c(1, 786)])), nrow = 28)) #look at one digit
    image(digit, col = grey.colors(255))
}
#a bunch of fours some are different


par(mfrow=c(3,3))
for (i in 10:18){
    digit <- flip(matrix(rev(as.numeric(train7[i,-c(1, 786)])), nrow = 28)) #look at one digit
    image(digit, col = grey.colors(255))
}
```

Guess I am not so weird after all! See that seven in the middle, the one with the line though it? That's how I do it. Also notice how there are two different ways to do four as well. Interestingly these two are topologically different. One way has a "hole"" in the middle and the other doesn't. I was considering at first a topological approach to this classification - perhaps counting the holes in the digits but given the variability in the writing this will probably not work. 


